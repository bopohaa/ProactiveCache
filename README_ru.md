# Общее описание
Простая реализация шаблона "cache-aside" с упреждающим обновлением значений по запросу до истечения срока жизни значения в кеше.

## Особенности
* Может использовать как свой внутренний кеш (если при создании кеша не указывать параметр `external_cache`, то по умолчанию будет создан отдельный экземпляр класса `ProactiveCache.MemoryCache`),
так и любой сторонний (например для `System.Runtime.Caching.MemoryCache` достаточно написать класс-обертку реализующий интерфейс ProactiveCache.ICache).
* Позволяет обновлять значение в кеше до истечения срока жизни этого значения путем указания времени до обновления - `outdate_ttl`.
По истечению этого времени первая операция чтения из кеша инициирует обновление значения, а все последующие операции чтения будут получать старое значение из кеше вплоть до завершения операции обновления.
* Есть специальная реализация кеша для обновления и получения сразу нескольких значений из кеша путем передачи перечисления ключей (`ProactiveCache.ProCacheBatch`).
В этом случае функция запроса значений получит список ключей значения которых нужно обновить либо добавить в кеш.
Если в результате работы такой функции будут возвращены значения не всех запрошенных ключей, то отсутствующие значения будут помечены как "пустые" и не будут в включены в результат,
но при этом буду запрошены заново по истечению времени акутальности в кеше.
* Специальная реализация механизма hooks позволит отслеживать некоторые события возникающие внутри кеша (miss - значение отсутствует в кеше, outdated - значение требует обновления, expired - значение было удалено из кеша).

## Вопросы производительности
* Время актуальности (время до устаревания значения `outdate_ttl`) значения в кеше должно быть достаточно продолжительным что бы не возникло дублирующих запросов обновления.
Лучшей практикой будет указание этого значения равным половине времени жизни значения в кеше (`outdate_ttl`=`expire_ttl`/2).
Если время получения значения правысит время устаревания то будет инициирован повторный запрос на обновление этого значения.
* Несмотря на строгую типизацию кеша, каждое значения будет храняться в куче даже если имеет value тип (принудительный `boxing` и `unboxing`).

## Примеры использования
Различные сценарии использования можно найти в тестах к этой библиотеки `ProactiveCacheTests`

### Пример получения значения по ключу
Получение одиночного значения из кеша по его ключу, в случае отсутсвтия значения вызов локального метода `getter`.
```C#
ValueTask<float> getter(int key, CancellationToken cancellation) => new ValueTask<float>(key);

var cache = ProCacheFactory
    .CreateOptions<int, float>(expire_ttl: TimeSpan.FromSeconds(120), outdate_ttl: TimeSpan.FromSeconds(60))
    .CreateCache(getter);

var result = cache.Get(1).Result;
```

### Пример получения нескольких значений по списку ключей
Получения нескольких значений из кеша по списку ключей, в случае отсутсвтия значения вызов локального метода `getter` со списком не найденных в кеше ключей.
В данном примере метод `getter` будет вызван дважды, первый раз со спиком ключей `[1,2,3]`, а во второй раз со списком ключей `[4,5,6]`
```C#
ValueTask<IEnumerable<KeyValuePair<int, float>>> getter(int[] keys, CancellationToken cancellation)
    => new ValueTask<IEnumerable<KeyValuePair<int, float>>>(keys.Select(k => new KeyValuePair<int, float>(k, k)));

var cache = ProCacheFactory
    .CreateOptions<int, float>(expire_ttl: TimeSpan.FromSeconds(120), outdate_ttl: TimeSpan.FromSeconds(60))
    .CreateCache(getter);

var from1to3 = cache.Get(Enumerable.Range(1, 3)).Result;
var from1to6 = cache.Get(Enumerable.Range(1, 6)).Result;
```